// lex.yy.cpp generated by reflex 5.2.2 from Lexer.l

#define REFLEX_VERSION "5.2.2"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "lex.yy.cpp"
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 13 "Lexer.l"

    std::vector<Token> tokens;
    void addToken(TokenType t, const std::string &lexeme, int ln, int col)
    {
        tokens.emplace_back(t, lexeme, ln, col);
    }

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, std::cout by default
      std::ostream& os = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  // bison-locations: yylloc_update() tracks lexeme locations
  virtual void yylloc_update(YYLTYPE& yylloc)
  {
    yylloc.first_line = static_cast<unsigned int>(matcher().lineno());
    yylloc.first_column = static_cast<unsigned int>(matcher().columno());
    yylloc.last_line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.last_column = static_cast<unsigned int>(matcher().columno_end());
  }
  // the bison-locations lexer function defined by SECTION 2
  virtual int lex(YYSTYPE& yylval, YYLTYPE& yylloc);
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 6 "Lexer.l"

#include <string>
#include <vector>
#include <unordered_map>
#include "Token.hpp"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON LOCATIONS                                                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

Lexer YY_SCANNER;

#ifndef YY_EXTERN_C
#define YY_EXTERN_C
#endif

YY_EXTERN_C int yylex(YYSTYPE *lvalp, YYLTYPE *llocp)
{
  return YY_SCANNER.lex(*lvalp, *llocp);
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int Lexer::lex(YYSTYPE& yylval, YYLTYPE& yylloc)
{
  static const char *REGEX_INITIAL = "(?m)((?:\\Q(\\E))|((?:\\Q)\\E))|((?:\\Q{\\E))|((?:\\Q}\\E))|((?:\\Q[\\E))|((?:\\Q]\\E))|((?:\\Q,\\E))|((?:\\Q.\\E))|((?:\\Q;\\E))|((?:\\Q:\\E))|((?:\\Q+\\E))|((?:\\Q-\\E))|((?:\\Q*\\E))|((?:\\Q/\\E))|((?:\\Q%\\E))|((?:\\Q&\\E))|((?:\\Q|\\E))|((?:\\Q^\\E))|((?:\\Q!\\E))|((?:\\Q~\\E))|((?:\\Q?\\E))|((?:\\Q<\\E))|((?:\\Q>\\E))|((?:\\Q=\\E))|((?:\\Q==\\E))|((?:\\Q!=\\E))|((?:\\Q<=\\E))|((?:\\Q>=\\E))|((?:\\Q&&\\E))|((?:\\Q||\\E))|((?:\\Q->\\E))|((?:\\Q::\\E))|((?:\\Q++\\E))|((?:\\Q--\\E))|((?:\\Q<<\\E))|((?:\\Q>>\\E))|([0-9]+)|((?:[A-Z]|_|[a-z]|\\xc2\\xb5|\\xc3[\\x80-\\x96]|\\xc3[\\x98-\\xb6]|\\xc3[\\xb8-\\xbf]|[\\xc4\\xc5][\\x80-\\xbf]|\\xc6[\\x80-\\xba]|\\xc6[\\xbc-\\xbf]|\\xc7\\x84|\\xc7[\\x86\\x87]|\\xc7[\\x89\\x8a]|\\xc7[\\x8c-\\xb1]|\\xc7[\\xb3-\\xbf]|[\\xc8\\xc9][\\x80-\\xbf]|\\xca[\\x80-\\x93]|\\xca[\\x95-\\xaf]|\\xcd[\\xb0-\\xb3]|\\xcd[\\xb6\\xb7]|\\xcd[\\xbb-\\xbd]|\\xcd\\xbf|\\xce\\x86|\\xce[\\x88-\\x8a]|\\xce\\x8c|\\xce[\\x8e-\\xa1]|\\xce[\\xa3-\\xbf]|\\xcf[\\x80-\\xb5]|\\xcf[\\xb7-\\xbf]|[\\xd0\\xd1][\\x80-\\xbf]|\\xd2[\\x80\\x81]|\\xd2[\\x8a-\\xbf]|\\xd3[\\x80-\\xbf]|\\xd4[\\x80-\\xaf]|\\xd4[\\xb1-\\xbf]|\\xd5[\\x80-\\x96]|\\xd5[\\xa0-\\xbf]|\\xd6[\\x80-\\x88]|\\xe1(?:\\x82[\\xa0-\\xbf]|\\x83[\\x80-\\x85])|\\xe1\\x83\\x87|\\xe1\\x83\\x8d|\\xe1\\x83[\\x90-\\xba]|\\xe1\\x83[\\xbd-\\xbf]|\\xe1(?:\\x8e[\\xa0-\\xbf]|\\x8f[\\x80-\\xb5])|\\xe1\\x8f[\\xb8-\\xbd]|\\xe1\\xb2[\\x80-\\x88]|\\xe1\\xb2[\\x90-\\xba]|\\xe1\\xb2[\\xbd-\\xbf]|\\xe1\\xb4[\\x80-\\xab]|\\xe1\\xb5[\\xab-\\xb7]|\\xe1(?:\\xb5[\\xb9-\\xbf]|\\xb6[\\x80-\\x9a])|\\xe1(?:[\\xb8-\\xbb][\\x80-\\xbf]|\\xbc[\\x80-\\x95])|\\xe1\\xbc[\\x98-\\x9d]|\\xe1(?:\\xbc[\\xa0-\\xbf]|\\xbd[\\x80-\\x85])|\\xe1\\xbd[\\x88-\\x8d]|\\xe1\\xbd[\\x90-\\x97]|\\xe1\\xbd\\x99|\\xe1\\xbd\\x9b|\\xe1\\xbd\\x9d|\\xe1\\xbd[\\x9f-\\xbd]|\\xe1\\xbe[\\x80-\\x87]|\\xe1\\xbe[\\x90-\\x97]|\\xe1\\xbe[\\xa0-\\xa7]|\\xe1\\xbe[\\xb0-\\xb4]|\\xe1\\xbe[\\xb6-\\xbb]|\\xe1\\xbe\\xbe|\\xe1\\xbf[\\x82-\\x84]|\\xe1\\xbf[\\x86-\\x8b]|\\xe1\\xbf[\\x90-\\x93]|\\xe1\\xbf[\\x96-\\x9b]|\\xe1\\xbf[\\xa0-\\xac]|\\xe1\\xbf[\\xb2-\\xb4]|\\xe1\\xbf[\\xb6-\\xbb]|\\xe2\\x84\\x82|\\xe2\\x84\\x87|\\xe2\\x84[\\x8a-\\x93]|\\xe2\\x84\\x95|\\xe2\\x84[\\x99-\\x9d]|\\xe2\\x84\\xa4|\\xe2\\x84\\xa6|\\xe2\\x84\\xa8|\\xe2\\x84[\\xaa-\\xad]|\\xe2\\x84[\\xaf-\\xb4]|\\xe2\\x84\\xb9|\\xe2\\x84[\\xbc-\\xbf]|\\xe2\\x85[\\x85-\\x89]|\\xe2\\x85\\x8e|\\xe2\\x86[\\x83\\x84]|\\xe2(?:\\xb0[\\x80-\\xbf]|\\xb1[\\x80-\\xbb])|\\xe2(?:\\xb1[\\xbe\\xbf]|\\xb2[\\x80-\\xbf]|\\xb3[\\x80-\\xa4])|\\xe2\\xb3[\\xab-\\xae]|\\xe2\\xb3[\\xb2\\xb3]|\\xe2\\xb4[\\x80-\\xa5]|\\xe2\\xb4\\xa7|\\xe2\\xb4\\xad|\\xea\\x99[\\x80-\\xad]|\\xea\\x9a[\\x80-\\x9b]|\\xea(?:\\x9c[\\xa2-\\xbf]|\\x9d[\\x80-\\xaf])|\\xea(?:\\x9d[\\xb1-\\xbf]|\\x9e[\\x80-\\x87])|\\xea\\x9e[\\x8b-\\x8e]|\\xea(?:\\x9e[\\x90-\\xbf]|\\x9f[\\x80-\\x8a])|\\xea\\x9f[\\x90\\x91]|\\xea\\x9f\\x93|\\xea\\x9f[\\x95-\\x99]|\\xea\\x9f[\\xb5\\xb6]|\\xea\\x9f\\xba|\\xea(?:\\xac[\\xb0-\\xbf]|\\xad[\\x80-\\x9a])|\\xea\\xad[\\xa0-\\xa8]|\\xea(?:\\xad[\\xb0-\\xbf]|\\xae[\\x80-\\xbf])|\\xef\\xac[\\x80-\\x86]|\\xef\\xac[\\x93-\\x97]|\\xef\\xbc[\\xa1-\\xba]|\\xef\\xbd[\\x81-\\x9a]|\\xf0\\x90(?:\\x90[\\x80-\\xbf]|\\x91[\\x80-\\x8f])|\\xf0\\x90(?:\\x92[\\xb0-\\xbf]|\\x93[\\x80-\\x93])|\\xf0\\x90\\x93[\\x98-\\xbb]|\\xf0\\x90\\x95[\\xb0-\\xba]|\\xf0\\x90(?:\\x95[\\xbc-\\xbf]|\\x96[\\x80-\\x8a])|\\xf0\\x90\\x96[\\x8c-\\x92]|\\xf0\\x90\\x96[\\x94\\x95]|\\xf0\\x90\\x96[\\x97-\\xa1]|\\xf0\\x90\\x96[\\xa3-\\xb1]|\\xf0\\x90\\x96[\\xb3-\\xb9]|\\xf0\\x90\\x96[\\xbb\\xbc]|\\xf0\\x90\\xb2[\\x80-\\xb2]|\\xf0\\x90\\xb3[\\x80-\\xb2]|\\xf0\\x91(?:\\xa2[\\xa0-\\xbf]|\\xa3[\\x80-\\x9f])|\\xf0\\x96\\xb9[\\x80-\\xbf]|\\xf0\\x9d(?:\\x90[\\x80-\\xbf]|\\x91[\\x80-\\x94])|\\xf0\\x9d(?:\\x91[\\x96-\\xbf]|\\x92[\\x80-\\x9c])|\\xf0\\x9d\\x92[\\x9e\\x9f]|\\xf0\\x9d\\x92\\xa2|\\xf0\\x9d\\x92[\\xa5\\xa6]|\\xf0\\x9d\\x92[\\xa9-\\xac]|\\xf0\\x9d\\x92[\\xae-\\xb9]|\\xf0\\x9d\\x92\\xbb|\\xf0\\x9d(?:\\x92[\\xbd-\\xbf]|\\x93[\\x80-\\x83])|\\xf0\\x9d(?:\\x93[\\x85-\\xbf]|\\x94[\\x80-\\x85])|\\xf0\\x9d\\x94[\\x87-\\x8a]|\\xf0\\x9d\\x94[\\x8d-\\x94]|\\xf0\\x9d\\x94[\\x96-\\x9c]|\\xf0\\x9d\\x94[\\x9e-\\xb9]|\\xf0\\x9d\\x94[\\xbb-\\xbe]|\\xf0\\x9d\\x95[\\x80-\\x84]|\\xf0\\x9d\\x95\\x86|\\xf0\\x9d\\x95[\\x8a-\\x90]|\\xf0\\x9d(?:\\x95[\\x92-\\xbf]|[\\x96-\\x99][\\x80-\\xbf]|\\x9a[\\x80-\\xa5])|\\xf0\\x9d(?:\\x9a[\\xa8-\\xbf]|\\x9b\\x80)|\\xf0\\x9d\\x9b[\\x82-\\x9a]|\\xf0\\x9d\\x9b[\\x9c-\\xba]|\\xf0\\x9d(?:\\x9b[\\xbc-\\xbf]|\\x9c[\\x80-\\x94])|\\xf0\\x9d\\x9c[\\x96-\\xb4]|\\xf0\\x9d(?:\\x9c[\\xb6-\\xbf]|\\x9d[\\x80-\\x8e])|\\xf0\\x9d\\x9d[\\x90-\\xae]|\\xf0\\x9d(?:\\x9d[\\xb0-\\xbf]|\\x9e[\\x80-\\x88])|\\xf0\\x9d\\x9e[\\x8a-\\xa8]|\\xf0\\x9d(?:\\x9e[\\xaa-\\xbf]|\\x9f[\\x80-\\x82])|\\xf0\\x9d\\x9f[\\x84-\\x8b]|\\xf0\\x9d\\xbc[\\x80-\\x89]|\\xf0\\x9d\\xbc[\\x8b-\\x9e]|\\xf0\\x9d\\xbc[\\xa5-\\xaa]|\\xf0\\x9e(?:\\xa4[\\x80-\\xbf]|\\xa5[\\x80-\\x83]))(?:[0-9]|[A-Z]|_|[a-z]|\\xc2\\xb5|\\xc3[\\x80-\\x96]|\\xc3[\\x98-\\xb6]|\\xc3[\\xb8-\\xbf]|[\\xc4\\xc5][\\x80-\\xbf]|\\xc6[\\x80-\\xba]|\\xc6[\\xbc-\\xbf]|\\xc7\\x84|\\xc7[\\x86\\x87]|\\xc7[\\x89\\x8a]|\\xc7[\\x8c-\\xb1]|\\xc7[\\xb3-\\xbf]|[\\xc8\\xc9][\\x80-\\xbf]|\\xca[\\x80-\\x93]|\\xca[\\x95-\\xaf]|\\xcd[\\xb0-\\xb3]|\\xcd[\\xb6\\xb7]|\\xcd[\\xbb-\\xbd]|\\xcd\\xbf|\\xce\\x86|\\xce[\\x88-\\x8a]|\\xce\\x8c|\\xce[\\x8e-\\xa1]|\\xce[\\xa3-\\xbf]|\\xcf[\\x80-\\xb5]|\\xcf[\\xb7-\\xbf]|[\\xd0\\xd1][\\x80-\\xbf]|\\xd2[\\x80\\x81]|\\xd2[\\x8a-\\xbf]|\\xd3[\\x80-\\xbf]|\\xd4[\\x80-\\xaf]|\\xd4[\\xb1-\\xbf]|\\xd5[\\x80-\\x96]|\\xd5[\\xa0-\\xbf]|\\xd6[\\x80-\\x88]|\\xd9[\\xa0-\\xa9]|\\xdb[\\xb0-\\xb9]|\\xdf[\\x80-\\x89]|\\xe0\\xa5[\\xa6-\\xaf]|\\xe0\\xa7[\\xa6-\\xaf]|\\xe0\\xa9[\\xa6-\\xaf]|\\xe0\\xab[\\xa6-\\xaf]|\\xe0\\xad[\\xa6-\\xaf]|\\xe0\\xaf[\\xa6-\\xaf]|\\xe0\\xb1[\\xa6-\\xaf]|\\xe0\\xb3[\\xa6-\\xaf]|\\xe0\\xb5[\\xa6-\\xaf]|\\xe0\\xb7[\\xa6-\\xaf]|\\xe0\\xb9[\\x90-\\x99]|\\xe0\\xbb[\\x90-\\x99]|\\xe0\\xbc[\\xa0-\\xa9]|\\xe1\\x81[\\x80-\\x89]|\\xe1\\x82[\\x90-\\x99]|\\xe1(?:\\x82[\\xa0-\\xbf]|\\x83[\\x80-\\x85])|\\xe1\\x83\\x87|\\xe1\\x83\\x8d|\\xe1\\x83[\\x90-\\xba]|\\xe1\\x83[\\xbd-\\xbf]|\\xe1(?:\\x8e[\\xa0-\\xbf]|\\x8f[\\x80-\\xb5])|\\xe1\\x8f[\\xb8-\\xbd]|\\xe1\\x9f[\\xa0-\\xa9]|\\xe1\\xa0[\\x90-\\x99]|\\xe1\\xa5[\\x86-\\x8f]|\\xe1\\xa7[\\x90-\\x99]|\\xe1\\xaa[\\x80-\\x89]|\\xe1\\xaa[\\x90-\\x99]|\\xe1\\xad[\\x90-\\x99]|\\xe1\\xae[\\xb0-\\xb9]|\\xe1\\xb1[\\x80-\\x89]|\\xe1\\xb1[\\x90-\\x99]|\\xe1\\xb2[\\x80-\\x88]|\\xe1\\xb2[\\x90-\\xba]|\\xe1\\xb2[\\xbd-\\xbf]|\\xe1\\xb4[\\x80-\\xab]|\\xe1\\xb5[\\xab-\\xb7]|\\xe1(?:\\xb5[\\xb9-\\xbf]|\\xb6[\\x80-\\x9a])|\\xe1(?:[\\xb8-\\xbb][\\x80-\\xbf]|\\xbc[\\x80-\\x95])|\\xe1\\xbc[\\x98-\\x9d]|\\xe1(?:\\xbc[\\xa0-\\xbf]|\\xbd[\\x80-\\x85])|\\xe1\\xbd[\\x88-\\x8d]|\\xe1\\xbd[\\x90-\\x97]|\\xe1\\xbd\\x99|\\xe1\\xbd\\x9b|\\xe1\\xbd\\x9d|\\xe1\\xbd[\\x9f-\\xbd]|\\xe1\\xbe[\\x80-\\x87]|\\xe1\\xbe[\\x90-\\x97]|\\xe1\\xbe[\\xa0-\\xa7]|\\xe1\\xbe[\\xb0-\\xb4]|\\xe1\\xbe[\\xb6-\\xbb]|\\xe1\\xbe\\xbe|\\xe1\\xbf[\\x82-\\x84]|\\xe1\\xbf[\\x86-\\x8b]|\\xe1\\xbf[\\x90-\\x93]|\\xe1\\xbf[\\x96-\\x9b]|\\xe1\\xbf[\\xa0-\\xac]|\\xe1\\xbf[\\xb2-\\xb4]|\\xe1\\xbf[\\xb6-\\xbb]|\\xe2\\x84\\x82|\\xe2\\x84\\x87|\\xe2\\x84[\\x8a-\\x93]|\\xe2\\x84\\x95|\\xe2\\x84[\\x99-\\x9d]|\\xe2\\x84\\xa4|\\xe2\\x84\\xa6|\\xe2\\x84\\xa8|\\xe2\\x84[\\xaa-\\xad]|\\xe2\\x84[\\xaf-\\xb4]|\\xe2\\x84\\xb9|\\xe2\\x84[\\xbc-\\xbf]|\\xe2\\x85[\\x85-\\x89]|\\xe2\\x85\\x8e|\\xe2\\x86[\\x83\\x84]|\\xe2(?:\\xb0[\\x80-\\xbf]|\\xb1[\\x80-\\xbb])|\\xe2(?:\\xb1[\\xbe\\xbf]|\\xb2[\\x80-\\xbf]|\\xb3[\\x80-\\xa4])|\\xe2\\xb3[\\xab-\\xae]|\\xe2\\xb3[\\xb2\\xb3]|\\xe2\\xb4[\\x80-\\xa5]|\\xe2\\xb4\\xa7|\\xe2\\xb4\\xad|\\xea\\x98[\\xa0-\\xa9]|\\xea\\x99[\\x80-\\xad]|\\xea\\x9a[\\x80-\\x9b]|\\xea(?:\\x9c[\\xa2-\\xbf]|\\x9d[\\x80-\\xaf])|\\xea(?:\\x9d[\\xb1-\\xbf]|\\x9e[\\x80-\\x87])|\\xea\\x9e[\\x8b-\\x8e]|\\xea(?:\\x9e[\\x90-\\xbf]|\\x9f[\\x80-\\x8a])|\\xea\\x9f[\\x90\\x91]|\\xea\\x9f\\x93|\\xea\\x9f[\\x95-\\x99]|\\xea\\x9f[\\xb5\\xb6]|\\xea\\x9f\\xba|\\xea\\xa3[\\x90-\\x99]|\\xea\\xa4[\\x80-\\x89]|\\xea\\xa7[\\x90-\\x99]|\\xea\\xa7[\\xb0-\\xb9]|\\xea\\xa9[\\x90-\\x99]|\\xea(?:\\xac[\\xb0-\\xbf]|\\xad[\\x80-\\x9a])|\\xea\\xad[\\xa0-\\xa8]|\\xea(?:\\xad[\\xb0-\\xbf]|\\xae[\\x80-\\xbf])|\\xea\\xaf[\\xb0-\\xb9]|\\xef\\xac[\\x80-\\x86]|\\xef\\xac[\\x93-\\x97]|\\xef\\xbc[\\x90-\\x99]|\\xef\\xbc[\\xa1-\\xba]|\\xef\\xbd[\\x81-\\x9a]|\\xf0\\x90(?:\\x90[\\x80-\\xbf]|\\x91[\\x80-\\x8f])|\\xf0\\x90\\x92[\\xa0-\\xa9]|\\xf0\\x90(?:\\x92[\\xb0-\\xbf]|\\x93[\\x80-\\x93])|\\xf0\\x90\\x93[\\x98-\\xbb]|\\xf0\\x90\\x95[\\xb0-\\xba]|\\xf0\\x90(?:\\x95[\\xbc-\\xbf]|\\x96[\\x80-\\x8a])|\\xf0\\x90\\x96[\\x8c-\\x92]|\\xf0\\x90\\x96[\\x94\\x95]|\\xf0\\x90\\x96[\\x97-\\xa1]|\\xf0\\x90\\x96[\\xa3-\\xb1]|\\xf0\\x90\\x96[\\xb3-\\xb9]|\\xf0\\x90\\x96[\\xbb\\xbc]|\\xf0\\x90\\xb2[\\x80-\\xb2]|\\xf0\\x90\\xb3[\\x80-\\xb2]|\\xf0\\x90\\xb4[\\xb0-\\xb9]|\\xf0\\x91\\x81[\\xa6-\\xaf]|\\xf0\\x91\\x83[\\xb0-\\xb9]|\\xf0\\x91\\x84[\\xb6-\\xbf]|\\xf0\\x91\\x87[\\x90-\\x99]|\\xf0\\x91\\x8b[\\xb0-\\xb9]|\\xf0\\x91\\x91[\\x90-\\x99]|\\xf0\\x91\\x93[\\x90-\\x99]|\\xf0\\x91\\x99[\\x90-\\x99]|\\xf0\\x91\\x9b[\\x80-\\x89]|\\xf0\\x91\\x9c[\\xb0-\\xb9]|\\xf0\\x91(?:\\xa2[\\xa0-\\xbf]|\\xa3[\\x80-\\xa9])|\\xf0\\x91\\xa5[\\x90-\\x99]|\\xf0\\x91\\xb1[\\x90-\\x99]|\\xf0\\x91\\xb5[\\x90-\\x99]|\\xf0\\x91\\xb6[\\xa0-\\xa9]|\\xf0\\x91\\xbd[\\x90-\\x99]|\\xf0\\x96\\xa9[\\xa0-\\xa9]|\\xf0\\x96\\xab[\\x80-\\x89]|\\xf0\\x96\\xad[\\x90-\\x99]|\\xf0\\x96\\xb9[\\x80-\\xbf]|\\xf0\\x9d(?:\\x90[\\x80-\\xbf]|\\x91[\\x80-\\x94])|\\xf0\\x9d(?:\\x91[\\x96-\\xbf]|\\x92[\\x80-\\x9c])|\\xf0\\x9d\\x92[\\x9e\\x9f]|\\xf0\\x9d\\x92\\xa2|\\xf0\\x9d\\x92[\\xa5\\xa6]|\\xf0\\x9d\\x92[\\xa9-\\xac]|\\xf0\\x9d\\x92[\\xae-\\xb9]|\\xf0\\x9d\\x92\\xbb|\\xf0\\x9d(?:\\x92[\\xbd-\\xbf]|\\x93[\\x80-\\x83])|\\xf0\\x9d(?:\\x93[\\x85-\\xbf]|\\x94[\\x80-\\x85])|\\xf0\\x9d\\x94[\\x87-\\x8a]|\\xf0\\x9d\\x94[\\x8d-\\x94]|\\xf0\\x9d\\x94[\\x96-\\x9c]|\\xf0\\x9d\\x94[\\x9e-\\xb9]|\\xf0\\x9d\\x94[\\xbb-\\xbe]|\\xf0\\x9d\\x95[\\x80-\\x84]|\\xf0\\x9d\\x95\\x86|\\xf0\\x9d\\x95[\\x8a-\\x90]|\\xf0\\x9d(?:\\x95[\\x92-\\xbf]|[\\x96-\\x99][\\x80-\\xbf]|\\x9a[\\x80-\\xa5])|\\xf0\\x9d(?:\\x9a[\\xa8-\\xbf]|\\x9b\\x80)|\\xf0\\x9d\\x9b[\\x82-\\x9a]|\\xf0\\x9d\\x9b[\\x9c-\\xba]|\\xf0\\x9d(?:\\x9b[\\xbc-\\xbf]|\\x9c[\\x80-\\x94])|\\xf0\\x9d\\x9c[\\x96-\\xb4]|\\xf0\\x9d(?:\\x9c[\\xb6-\\xbf]|\\x9d[\\x80-\\x8e])|\\xf0\\x9d\\x9d[\\x90-\\xae]|\\xf0\\x9d(?:\\x9d[\\xb0-\\xbf]|\\x9e[\\x80-\\x88])|\\xf0\\x9d\\x9e[\\x8a-\\xa8]|\\xf0\\x9d(?:\\x9e[\\xaa-\\xbf]|\\x9f[\\x80-\\x82])|\\xf0\\x9d\\x9f[\\x84-\\x8b]|\\xf0\\x9d\\x9f[\\x8e-\\xbf]|\\xf0\\x9d\\xbc[\\x80-\\x89]|\\xf0\\x9d\\xbc[\\x8b-\\x9e]|\\xf0\\x9d\\xbc[\\xa5-\\xaa]|\\xf0\\x9e\\x85[\\x80-\\x89]|\\xf0\\x9e\\x8b[\\xb0-\\xb9]|\\xf0\\x9e\\x93[\\xb0-\\xb9]|\\xf0\\x9e(?:\\xa4[\\x80-\\xbf]|\\xa5[\\x80-\\x83])|\\xf0\\x9e\\xa5[\\x90-\\x99]|\\xf0\\x9f\\xaf[\\xb0-\\xb9])*)|((?:.[\\x80-\\xbf]*))";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        matcher().scan();
        yylloc_update(yylloc);
        switch (matcher().accept())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule Lexer.l:23: "(" :
#line 23 "Lexer.l"
{ addToken(TokenType::LeftParen, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 2: // rule Lexer.l:24: ")" :
#line 24 "Lexer.l"
{ addToken(TokenType::RightParen, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 3: // rule Lexer.l:25: "{" :
#line 25 "Lexer.l"
{ addToken(TokenType::LeftBrace, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 4: // rule Lexer.l:26: "}" :
#line 26 "Lexer.l"
{ addToken(TokenType::RightBrace, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 5: // rule Lexer.l:27: "[" :
#line 27 "Lexer.l"
{ addToken(TokenType::LeftBracket, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 6: // rule Lexer.l:28: "]" :
#line 28 "Lexer.l"
{ addToken(TokenType::RightBracket, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 7: // rule Lexer.l:29: "," :
#line 29 "Lexer.l"
{ addToken(TokenType::Comma, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 8: // rule Lexer.l:30: "." :
#line 30 "Lexer.l"
{ addToken(TokenType::Dot, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 9: // rule Lexer.l:31: ";" :
#line 31 "Lexer.l"
{ addToken(TokenType::Semicolon, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 10: // rule Lexer.l:32: ":" :
#line 32 "Lexer.l"
{ addToken(TokenType::Colon, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 11: // rule Lexer.l:33: "+" :
#line 33 "Lexer.l"
{ addToken(TokenType::Plus, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 12: // rule Lexer.l:34: "-" :
#line 34 "Lexer.l"
{ addToken(TokenType::Minus, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 13: // rule Lexer.l:35: "*" :
#line 35 "Lexer.l"
{ addToken(TokenType::Star, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 14: // rule Lexer.l:36: "/" :
#line 36 "Lexer.l"
{ addToken(TokenType::Slash, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 15: // rule Lexer.l:37: "%" :
#line 37 "Lexer.l"
{ addToken(TokenType::Percent, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 16: // rule Lexer.l:38: "&" :
#line 38 "Lexer.l"
{ addToken(TokenType::Ampersand, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 17: // rule Lexer.l:39: "|" :
#line 39 "Lexer.l"
{ addToken(TokenType::Pipe, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 18: // rule Lexer.l:40: "^" :
#line 40 "Lexer.l"
{ addToken(TokenType::Caret, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 19: // rule Lexer.l:41: "!" :
#line 41 "Lexer.l"
{ addToken(TokenType::Exclamation, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 20: // rule Lexer.l:42: "~" :
#line 42 "Lexer.l"
{ addToken(TokenType::Tilde, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 21: // rule Lexer.l:43: "?" :
#line 43 "Lexer.l"
{ addToken(TokenType::Question, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 22: // rule Lexer.l:44: "<" :
#line 44 "Lexer.l"
{ addToken(TokenType::Less, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 23: // rule Lexer.l:45: ">" :
#line 45 "Lexer.l"
{ addToken(TokenType::Greater, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 24: // rule Lexer.l:46: "=" :
#line 46 "Lexer.l"
{ addToken(TokenType::Equals, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 25: // rule Lexer.l:47: "==" :
#line 47 "Lexer.l"
{ addToken(TokenType::DoubleEquals, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 26: // rule Lexer.l:48: "!=" :
#line 48 "Lexer.l"
{ addToken(TokenType::NotEquals, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 27: // rule Lexer.l:49: "<=" :
#line 49 "Lexer.l"
{ addToken(TokenType::LessEquals, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 28: // rule Lexer.l:50: ">=" :
#line 50 "Lexer.l"
{ addToken(TokenType::GreaterEquals, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 29: // rule Lexer.l:51: "&&" :
#line 51 "Lexer.l"
{ addToken(TokenType::DoubleAmpersand, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 30: // rule Lexer.l:52: "||" :
#line 52 "Lexer.l"
{ addToken(TokenType::DoublePipe, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 31: // rule Lexer.l:53: "->" :
#line 53 "Lexer.l"
{ addToken(TokenType::Arrow, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 32: // rule Lexer.l:54: "::" :
#line 54 "Lexer.l"
{ addToken(TokenType::Scope, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 33: // rule Lexer.l:55: "++" :
#line 55 "Lexer.l"
{ addToken(TokenType::Increment, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 34: // rule Lexer.l:56: "--" :
#line 56 "Lexer.l"
{ addToken(TokenType::Decrement, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 35: // rule Lexer.l:57: "<<" :
#line 57 "Lexer.l"
{ addToken(TokenType::LShift, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 36: // rule Lexer.l:58: ">>" :
#line 58 "Lexer.l"
{ addToken(TokenType::RShift, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 37: // rule Lexer.l:59: [0-9]+ :
#line 59 "Lexer.l"
{ addToken(TokenType::IntegerLiteral, yytext, yylloc->last_line, yylloc->last_column); }
            break;
          case 38: // rule Lexer.l:60: [[:alpha:]_][[:alnum:]_]* :
#line 60 "Lexer.l"
{
    static std::unordered_map<std::string, TokenType> keywords = {
        {"auto",TokenType::Auto},
        {"struct",TokenType::Struct},
        {"class",TokenType::Class},
        {"union",TokenType::Union},
        {"enum",TokenType::Enum},
        {"namespace",TokenType::Namespace},
        {"import",TokenType::Import},
        {"as",TokenType::As},
        {"if",TokenType::If},
        {"else",TokenType::Else},
        {"for",TokenType::For},
        {"in",TokenType::In},
        {"while",TokenType::While},
        {"return",TokenType::Return},
        {"label",TokenType::Label},
        {"goto",TokenType::Goto},
        {"case",TokenType::Case},
        {"match",TokenType::Match},
        {"true",TokenType::True},
        {"false",TokenType::False},
        {"public",TokenType::Public},
        {"private",TokenType::Private},
        {"string",TokenType::String},
        {"char",TokenType::Char},
        {"bool",TokenType::Bool},
        {"void",TokenType::Void},
        {"float",TokenType::Float},
        {"double",TokenType::Double},
        {"int64",TokenType::Int64},
        {"int32",TokenType::Int32},
        {"int16",TokenType::Int16},
        {"int8",TokenType::Int8},
        {"uint64",TokenType::UInt64},
        {"uint32",TokenType::UInt32},
        {"uint16",TokenType::UInt16},
        {"uint8",TokenType::UInt8},
        {"ptr",TokenType::Ptr}
    };
    std::string text = yytext;
    auto it = keywords.find(text);
    if (it != keywords.end())
    {
        addToken(it->second, text, yylloc->last_line, yylloc->last_column);
    } else
    {
        addToken(TokenType::Identifier, text, yylloc->last_line, yylloc->last_column);
    }
}
            break;
          case 39: // rule Lexer.l:110: . :
#line 110 "Lexer.l"
{ addToken(TokenType::Invalid, yytext, yylloc->last_line, yylloc->last_column); }

            break;
        }
  }
}
